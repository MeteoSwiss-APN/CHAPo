---
title: "Implementation"
author: "Simon Adamov"
date: "August 12, 2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE,
                      error = FALSE, 
                      warning = FALSE, 
                      message = FALSE,
                      fig.retina =3,
                      fig.width = 10,
                      fig.height = 7,
                      out.width = "100%",
                      out.height = "100%")


library(mchdwh)
if (Sys.info()["nodename"] != "tsa-ln002") library(ROracle)
library(dplyr)
library(readr)
library(tidyr)
library(purrr)
library(stringr)
library(scales)
library(psych)
library(caret)
library(lubridate)
library(tsibble)
library(feasts)
library(fabletools)
library(kableExtra)
library(ggpubr)
# These themes just look great :-)
library(ggthemr)
# devtools::install_github('cttobin/ggthemr')
ggthemr("fresh")

devtools::load_all(".")

library(conflicted)
conflict_prefer(name = "select", winner = "dplyr")
conflict_prefer(name = "filter", winner = "dplyr")
conflict_prefer(name = "lag", winner = "dplyr")
conflict_prefer(name = "rescale", winner = "scales")

# remotes::install_version("caTools", version = "1.17.1.1")
# This library is needed for visual representation of missing data
# library(Amelia)
# remotes::install_version("foreign", version = "0.8-71")
# install.packages("Amelia")


```

# Data Import


The data is obtained from the DWH for the current pollen season (2020). 
The Model Data from COSMO-ART is available on tsa (CSCS) in /store.

```{r }

# The following types are being measured:
# Erle - Alder - Aulne - Alnus
# Birke - Birch - Bouleau - Betula
# Gräser - Grasses - Graminées - Poaceae
# Ambrosia - Ragweed - Ambroisie - Ambrosia

species_all <- tibble(
  taxon = c(
    "Castanea",
    "Alnus",
    "Ulmus",
    "Cupressus",
    "Fraxinus",
    "Fagus",
    "Juglans",
    "Plantago",
    "Corylus",
    "Pinus",
    "Quercus",
    "Rumex",
    "Platanus",
    "Populus",
    "Poaceae",
    "Salix",
    "Betula",
    "Carpinus",
    "Urtica",
    "Taxus",
    "Picea",
    "Ambrosia"
  ),
  hirst_taxon = c(
    "kacastz0",
    "kaalnuz0",
    "kaulmuz0",
    "kacuprz0",
    "kafraxz0",
    "kafaguz0",
    "kajuglz0",
    "khplanz0",
    "kacoryz0",
    "kapinuz0",
    "kaquerz0",
    "khrumez0",
    "kaplatz0",
    "kapopuz0",
    "khpoacz0",
    "kasaliz0",
    "kabetuz0",
    "kacarpz0",
    "khurtiz0",
    "kataxuz0",
    "kapicez0",
    "khambrz0"
  ),
  cosmo_taxon = c(
    NA_character_,
    "ALNU",
    NA_character_,
    NA_character_,
    NA_character_,
    NA_character_,
    NA_character_,
    NA_character_,
    NA_character_,
    NA_character_,
    NA_character_,
    NA_character_,
    NA_character_,
    NA_character_,
    "POAC",
    NA_character_,
    "BETU",
    NA_character_,
    NA_character_,
    NA_character_,
    NA_character_,
    "AMBR"
  )
)

species <- species_all %>%
  filter(taxon %in% c("Alnus", "Ambrosia", "Betula", "Poaceae"))

stations <-
  tibble(
    hirst_station = c(
      "PDS",
      "PBU",
      "PMU",
      "PBS",
      "PZH",
      "PLZ",
      "PBE",
      # "PPY",
      "PNE",
      "PVI",
      "PLS",
      "PGE",
      "PCF",
      "PLO",
      # "BLR",
      "PLU"
    ),
    station = c(
      "Wolfgang",
      "Buchs",
      "Münsterlingen",
      "Basel",
      "Zürich",
      "Luzern",
      "Bern",
      # "Payerne",
      "Neuchâtel",
      "Visp",
      "Lausanne",
      "Genève",
      "La-Chaux-de-Fonds",
      "Locarno",
      # "Balerna",
      "Lugano"
      ),
    cosmo_station = c(
      "CHDAVO",
      "CHBUCH",
      "CHMUEN",
      "CHBASE",
      "CHZUER",
      "CHLUZE",
      "CHBERN",
      # NA_character_,
      "CHNEUC",
      "CHVISP",
      "CHLAUS",
      "CHGENE",
      "CHLACH",
      "CHLOCA",
      # NA_character_,
      "CHLUGA"
    )
  )

```

## Measurements
```{r eval = FALSE}
# Loading the Data takes a long time and often fails when multiple years are retrieved.
data_hirst <- dwhget_surface(param_short = species$hirst_taxon,
                                  meas_cat = 204,
                                  year = 2017:2020,
                                  iso_country_cd = "CH") %>%
  mutate(datetime = ymd_hm(datetime),
  type = "Hirst",
  measurement = "concentration") %>%
  mutate_if(is.character, ~as.factor(.)) %>%
  inner_join(species, by = c("param_short" = "hirst_taxon")) %>%
  inner_join(stations, by = c("nat_abbr" = "hirst_station")) %>% 
  select(-param_short, -nat_abbr)

# save(data_hirst, file = paste0(here::here(), "/vignettes/ext-data/data_hirst.RData"))

# load(paste0(here::here(), "/vignettes/ext-data/data_hirst.RData"))

```

## Model COSMO-ART

```{r}
data_cosmo <- read_delim(paste0(here::here(), "/vignettes/ext-data/mod_pollen_2020_ch.csv"), delim = " ", skip = 17, col_names = TRUE, trim_ws = TRUE) %>% 
  mutate_at(vars(CHBASE:CHZUER), ~ ifelse(. < 0, NA_real_, .)) %>% # setting na during import failed for some reason 
  pivot_longer(CHBASE:CHZUER, names_to = "station_tag", values_to = "value") %>%  
  mutate(measurement = case_when(str_detect(PARAMETER, pattern = "sdes") ~ "phenology",
                                 str_detect(PARAMETER, pattern = "fe") ~ "emission",
                                 TRUE ~ "concentration"),
         PARAMETER = str_replace_all(PARAMETER, "sdes|fe", "")) %>% 
  inner_join(species, by = c("PARAMETER" = "cosmo_taxon")) %>% 
  inner_join(stations, by = c("station_tag" = "cosmo_station")) %>% 
  mutate(datetime = ymd_h(paste0(YYYY, sprintf("%02d", MM), sprintf("%02d", DD), sprintf("%02d", hh))),
         date = date(datetime),
         hour = hour(datetime),
         type = "Cosmo") %>% 
  # filter(between(datetime, as_datetime("2017-03-02 00:01:00"), as_datetime("2020-08-19 00:00:00"))) %>% 
  select(taxon, station, date, hour, value, datetime, type, measurement)

```


# Data Bias Correction
## Measurements

The team in Payerne found that the air sucking rates of the Hirst traps are actually higher in reality than reported by the manufacturer. The traps suck in 13.5 l per minute instead of 10 l per minute. Hence our Pollen counts per 10 minutes are too high and should be reduced by a factor of 1.35.

```{r eval = FALSE}
data_hirst<- data_hirst %>% 
  mutate(value_unbiased = value / 1.35)
```

# Missing Data and Imputation
## Measurements

There are no missing measurements.
Generally, missing data usually occurs when the silicone rubber bands were being exchanged.
Are they being imputed before storing the data on the DWH?

```{r  eval = FALSE}

# This takes ~ 2minutes - visual representation of missing data
# data_hirst %>% 
#   as.data.frame() %>% 
#   missmap(y.labels = "", y.at = 1, col = swatch()[c(4,2)])

data_hirst %>% 
  summarise_all(~sum(is.na(.)))

summary(data_hirst)

```

## Model COSMO-ART

```{r}
data_cosmo %>% 
  summarise_all(~sum(is.na(.)))

summary(data_cosmo)
```

# Temporal Aggregation
## Measurements

There are some general guidelines from Regula Gehrig on how to average concentration that should be followed here.

Die Stundenwerte werden wie folgt aus den 10-Minutenwerten berechnet:
z.B. Wert für 6:00 Uhr UTC wird berechnet aus 05:10 – 6:00 UTC

Die 3-h-Werte, die du auch im DWH findest, werden so berechnet:
z.B. Wert um 09:00 UTC: 06:10-09:00

Die Tageswerte werden bei den Pollen glaub ich aus den Stundenwerten berechnet aus:
01:00 – 24:00 (d.h. 00:00 – im DWH gibt es keinen Wert 24:00) UTC 


```{r eval = FALSE}

data_hirst <- data_hirst %>%
  mutate(date = date(datetime),
         hms = format(datetime, "%H:%M:%S"),
         hour = lag(hour(datetime), 1) + 1,
         hour = ifelse(hour == 24, 0, hour))
  
data_hirst_window <- data_hirst %>% 
  filter(between(datetime, as_datetime("2017-03-02 00:10:00"), as_datetime("2020-08-19 00:00:00"))) # Only look at full days

data_hourly <- data_hirst_window
         
data_2hours <- data_hirst_window %>%
      mutate(hour = case_when(
      hms > "00:00:00" & hms <= "02:00:00" ~ 2,
      hms > "02:00:00" & hms <= "04:00:00" ~ 4,
      hms > "04:00:00" & hms <= "06:00:00" ~ 6,
      hms > "06:00:00" & hms <= "08:00:00" ~ 8,
      hms > "08:00:00" & hms <= "10:00:00" ~ 10,
      hms > "10:00:00" & hms <= "12:00:00" ~ 12,
      hms > "12:00:00" & hms <= "14:00:00" ~ 14,
      hms > "14:00:00" & hms <= "16:00:00" ~ 16,
      hms > "16:00:00" & hms <= "18:00:00" ~ 18,
      hms > "18:00:00" & hms <= "20:00:00" ~ 20,
      hms > "20:00:00" & hms <= "22:00:00" ~ 22,
      hms > "22:00:00" | hms == "00:00:00" ~ 0 # For the next day already
    ))

data_3hours <- data_hirst_window %>%
  mutate(
    hour = case_when(
      hms > "00:00:00" & hms <= "03:00:00" ~ 3,
      hms > "03:00:00" & hms <= "06:00:00" ~ 6,
      hms > "06:00:00" & hms <= "09:00:00" ~ 9,
      hms > "09:00:00" & hms <= "12:00:00" ~ 12,
      hms > "12:00:00" & hms <= "15:00:00" ~ 15,
      hms > "15:00:00" & hms <= "18:00:00" ~ 18,
      hms > "18:00:00" & hms <= "21:00:00" ~ 21,
      hms > "21:00:00" | hms == "00:00:00" ~ 0 # For the next day already
    ))

data_6hours <- data_hirst_window %>%
  mutate(
    hour = case_when(
      hms > "00:00:00" & hms <= "06:00:00" ~ 6,
      hms > "06:00:00" & hms <= "12:00:00" ~ 12,
      hms > "12:00:00" & hms <= "18:00:00" ~ 18,
      hms > "18:00:00" | hms == "00:00:00" ~ 0 # For the next day already
    ))

data_12hours <- data_hirst_window %>%
  mutate(
    hour = case_when(
      hms > "00:00:00" & hms <= "12:00:00" ~ 12,
      hms > "12:00:00" | hms == "00:00:00" ~ 0 # For the next day already
    ))

data <- map(list(data_hourly, data_2hours, data_3hours, data_6hours, data_12hours), ~.x %>% 
  mutate(date = if_else(hour == 0 & hms != "00:00:00", date + days(1), date)) %>% # This way they will be allocated to the next day
  group_by(taxon, station, date, hour, type, measurement) %>% 
  summarise(value = mean(value_unbiased)) %>% 
  ungroup() %>% 
  mutate(datetime = ymd_hm(paste0(as.character(date), paste0(sprintf("%02d", hour), ":00")))) %>% 
  select(taxon, station, date, hour, value, datetime, type, measurement))

data[[6]] <- data[[1]] %>% 
  group_by(date, station, taxon, type, measurement) %>% 
  summarise(value = mean(value)) %>% 
  ungroup() %>% 
  mutate(datetime = date,
         hour = 00:00) %>% 
  select(taxon, station, date, hour, value, datetime, type, measurement)

names(data) <- c("data_hourly", "data_2hours", "data_3hours", "data_6hours", "data_12hours", "data_daily")

save(data, file = paste0(here::here(), "/vignettes/ext-data/data_aggs.RData"))
  
``` 

```{r}
load(paste0(here::here(), "/vignettes/ext-data/data_aggs.RData"))
```


# Time Series Plots

```{r}
data_hourly_comb <- data$data_hourly %>% 
    filter(datetime >= ymd_h("2020-01-01 00")) %>% 
    bind_rows(data_cosmo) 

data_daily_comb <- data_hourly_comb %>% 
  group_by(taxon, station, date, type) %>% 
  summarise(value = mean(value, na.rm = TRUE)) %>% 
  ungroup %>% 
  mutate(hour = 0,
         # date = date + days(1), # Depends on the definition
         datetime = ymd_hm(paste0(as.character(date), paste0(sprintf("%02d", hour), ":00"))))
```


```{r }

# gg_comparison <- plot_hirst(species = species, resolution = resolution, rm_zeros = TRUE, combined = TRUE)

plot_comb(combined = TRUE, taxon = "Alnus", station = "Bern", resolution = "Daily", rm_zeros = FALSE)

```


```{r }

occurence <- data_daily_comb %>% 
  group_by(taxon, station, type) %>% 
  summarise(value = sum(value != 0, na.rm = TRUE)) %>% 
  ungroup() %>% 
  mutate(metric = "occurence")

maximum <- data_daily_comb %>% 
  group_by(taxon, station, type) %>% 
  summarise(value = max(value, na.rm = TRUE)) %>% 
  ungroup() %>% 
  mutate(metric = "maximum")

average <- data_daily_comb %>% 
  group_by(taxon, station, type) %>% 
  summarise(value = mean(value, na.rm = TRUE)) %>% 
  ungroup() %>% 
  mutate(metric = "average")

spi <- data_daily_comb %>% 
  group_by(taxon, station, type) %>% 
  summarise(value = sum(value, na.rm = TRUE)) %>% 
  ungroup() %>% 
  mutate(metric = "spi")

metrics <- bind_rows(occurence,
                  maximum,
                  average,
                  spi)

create_kable(occurence, title = "Occurence of Pollen [Days]")
create_kable(maximum, title = "Maximum Pollen Concentration [m⁻³]")
create_kable(average, title = "Average Pollen Concentration [m⁻³]")
create_kable(spi, title = "Seasonal Pollen Integral [days*m⁻³]")

```

```{r fig.height=9, fig.width=16, eval = FALSE}
stations_subset <- map(c(4, 8, 12, 16), ~stations %>% 
                         arrange(station) %>% 
                         slice((.x - 3):.x) %>% 
                         pull(station))

map(stations_subset, ~data$data_daily %>% 
  filter(station %in% .x) %>% 
  ggplot(aes(x = datetime, y = value, col = taxon)) +
    geom_line() +
    # coord_cartesian(ylim = c(0, 5000)) +
    labs(y = expression(paste("Pollen Concentration [", m^-3, "]")),
       x = "") +
  scale_colour_discrete("") +
    facet_wrap(~station))
```

## Concentrations

```{r fig.height=6, fig.width=9}

# stations_selected <- "Zürich" # Check stations tibble for all available locations
taxa_selected <- c("Alnus", "Betula", "Poaceae", "Ambrosia") # Check species tibble for all available pollen taxa
gg_timeseries <- list()

for (s in stations$station %>% sort){
  data_timeseries <- data$data_hourly %>% 
    filter(datetime >= ymd_h("2020-01-01 00")) %>% 
    bind_rows(data_cosmo) %>% 
    filter(taxon %in% taxa_selected,
           station %in% s,
           measurement == "concentration") %>% 
    group_by(type, taxon, date, station) %>%
    summarise(value = mean(value, na.rm = TRUE)) %>%
    ungroup 
  
  large_diffs <- data_timeseries %>%
    pivot_wider(names_from = type) %>% 
    mutate(diff = Hirst - Cosmo,
           mean_pol = (Hirst + Cosmo) / 2,
           large_diff = if_else(Hirst > 20 & ((abs(diff) + mean_pol) / mean_pol > 2), date, as.Date(NA))) %>% 
    pull(large_diff) %>% 
    unique()
  
  gg_timeseries[[s]] <- data_timeseries %>% 
    ggplot(aes(x = date, y = value, col = taxon, lty = type)) +
      geom_line(alpha = 0.6) +
      geom_vline(xintercept = large_diffs, alpha = 0.1, col = swatch()[1], size = 1) +
      ggtitle(paste("Hourly", paste(taxa_selected, collapse = ", "), "Pollen Concentrations in", s)) +
    labs(y = expression(paste("Pollen Concentration [", m^-3, "]")),
         x = "2020 Season") +
    scale_colour_discrete("Species") +
    scale_linetype_discrete("Data") +
    coord_cartesian(xlim = c(ymd("2020-01-15"), ymd("2020-09-01")),
                    ylim = c(0, 2000)) 
}

gg_timeseries

```

## Phenology

```{r fig.height=6, fig.width=9}

# stations_selected <- "Zürich" # Check stations tibble for all available locations
taxa_selected <- c("Alnus", "Betula", "Poaceae", "Ambrosia") # Check species tibble for all available pollen taxa
gg_pheno <- list()

for (s in stations$station %>% sort){
  gg_pheno[[s]] <- data$data_hourly %>% 
    filter(datetime >= ymd_h("2020-01-01 00")) %>% 
    bind_rows(data_cosmo) %>% 
    filter(taxon %in% taxa_selected,
           station %in% s,
           measurement == "concentration" & type == "Hirst" | measurement == "phenology" & type == "Cosmo") %>% 
    group_by(type, taxon, date, station) %>%
    summarise(value = mean(value, na.rm = TRUE)) %>%
    ungroup %>% 
    group_by(type) %>% 
    mutate(value = rescale(value, to = c(0, 100))) %>% 
    ggplot(aes(x = date, y = value, col = taxon, lty = type)) +
      geom_line(alpha = 0.6) +
      ggtitle(paste("Hourly", paste(taxa_selected, collapse = ", "), "Pollen Phenology in", s)) +
      labs(y = expression(paste("Pollen Phenology")),
         x = "2020 Season") +
      scale_colour_discrete("Species") +
      scale_linetype_discrete("Data") +
      coord_cartesian(xlim = c(ymd("2020-01-15"), ymd("2020-09-01")),
                      ylim = c(0, 100)) 
}

gg_pheno

```

## Emission Flux

```{r fig.height=6, fig.width=9}

# stations_selected <- "Zürich" # Check stations tibble for all available locations
taxa_selected <- c("Alnus", "Betula", "Poaceae", "Ambrosia") # Check species tibble for all available pollen taxa
gg_emiss <- list()

for (s in stations$station %>% sort){
  gg_emiss[[s]] <- data$data_hourly %>% 
    filter(datetime >= ymd_h("2020-01-01 00")) %>% 
    bind_rows(data_cosmo) %>% 
    filter(taxon %in% taxa_selected,
           station %in% s,
           measurement == "concentration" & type == "Hirst" | measurement == "emission" & type == "Cosmo") %>% 
    group_by(type, taxon, date, station) %>%
    summarise(value = mean(value, na.rm = TRUE)) %>%
    ungroup %>% 
    group_by(type) %>% 
    mutate(value = rescale(value, to = c(0, 100))) %>% 
    ggplot(aes(x = date, y = value, col = taxon, lty = type)) +
      geom_line(alpha = 0.6) +
      ggtitle(paste("Hourly", paste(taxa_selected, collapse = ", "), "Pollen Emission Flux in", s)) +
      labs(y = expression(paste("Pollen Emission Flux")),
         x = "2020 Season") +
      scale_colour_discrete("Species") +
      scale_linetype_discrete("Data") +
      coord_cartesian(xlim = c(ymd("2020-01-15"), ymd("2020-09-01")),
                      ylim = c(0, 100)) 
}

gg_emiss

```

# Correlation

The correlation between the measurements and modeled data can be calculated easily.
As we are only comparing two sets of data, mutliple testing is not a problem here.

Careful the correlation coefficients method have some serious shortcomings:

The correlation coefficient measures linear agreement--whether the measurements go up-and-down together. Certainly, we want the measures to go up-and-down together, but the correlation coefficient itself is deficient in at least three ways as a measure of agreement. (http://www.jerrydallal.com/LHSP/compare.htm)

- The correlation coefficient can be close to 1 (or equal to 1!) even when there is considerable bias between the two methods. For example, if one method gives measurements that are always 10 units higher than the other method, the correlation will be 1 exactly, but the measurements will always be 10 units apart.
- The magnitude of the correlation coefficient is affected by the range of subjects/units studied. The correlation coefficient can be made smaller by measuring samples that are similar to each other and larger by measuring samples that are very different from each other. The magnitude of the correlation says nothing about the magnitude of the differences between the paired measurements which, when you get right down to it, is all that really matters.
- The usual significance test involving a correlation coefficient-- whether the population value is 0--is irrelevant to the comparability problem. What is important is not merely that the correlation coefficient be different from 0. Rather, it should be close to (ideally, equal to) 1! 

## Pearson, Spearman and Kendall Correlation

A good summary of the methods and their shortcomings can be found here: https://www.statisticssolutions.com/correlation-Pearson-Kendall-spear man/

Generally the traps show a high level of correlation / association (well above 0.5). It looks like small concentrations lead to the largest discrepancies between the two sets of data.

```{r}

methods <- c("pearson", "spearman", "kendall")

data_corr <- data_daily_comb %>% 
  mutate(value = log10(value + 1)) %>% # For the robust methods (spearman, kendall) it doesn't matter whether the transformed data is used or the original
  select(value, type, datetime, station, taxon) %>% 
  pivot_wider(names_from = type, values_from = value)

data_corr_exp <- data_daily_comb %>% 
  select(value, type, datetime, station, taxon) %>% 
  pivot_wider(names_from = type, values_from = value)

corr_matrix <- map(methods, ~corr.test(
  data_corr %>% select(-datetime, -station, -taxon),
  use = "complete",
  method = .x,
  # adjust = "holm",
  alpha = .05,
  ci = TRUE,
  minlength = 5
  ))

```

```{r }
ggthemr("fresh")
ci <- map(corr_matrix, ~.x %>% 
  pluck(10)) %>% 
  bind_rows() %>% 
  round(2) %>% 
  mutate(method = methods,
         metric = c("R-", "rho-", "tau-"),
         ci = tools::toTitleCase(paste0(metric, method, ": ", lower.adj, " - ", upper.adj)),
         x = rep(1, times = 3),
         y = c(3.75, 3.5, 3.25))

gg_corr <- data_corr %>% 
  ggplot(aes(x = Hirst, y = Cosmo)) + 
  geom_point(alpha = 0.3) +
  geom_smooth(data = data_corr, alpha = 0.1) +
  geom_abline(slope = 1, intercept = 0, col = swatch()[4]) +
  geom_label(data = ci, aes(label = ci, x = x, y = y), parse = TRUE) +
  coord_cartesian(ylim = c(0, 4), xlim = c(0, 4))

title <- tools::toTitleCase(paste0("Comparison of Daily average concentrations of measured and modelled pollen concentrations"))

ggarrange(gg_corr) %>%
  annotate_figure( top = title, bottom = text_grob("Pairwise correlation between traps; grey line shows the Loess smother; the red line shows a theroratical perfect correlation of 1. \n In the text box one can see the 95% confidence intervals of the R-values (adjusted for multiple comparison) as obtained by Pearson and two robust methods.", color = swatch()[1], face = "italic", size = 10))

```

Comparison Plots

## Concentration Categories Diff-Plots

For the concentrations we are looking at some density plots and histograms to start with and then we look at the relative differences from the common mean of the three traps.

```{r}
data_altman <- data_corr %>% 
    mutate(mean = if_else(!is.na(Hirst) | !is.na(Cosmo),
                          rowSums(.[4:5], na.rm = TRUE) / 2, 
                          NA_real_),
           diff = Hirst - Cosmo)

data_altman_exp <- data_corr_exp %>% 
    mutate(mean = if_else(!is.na(Hirst) | !is.na(Cosmo),
                          rowSums(.[4:5], na.rm = TRUE) / 2, 
                          NA_real_),
           diff = Hirst - Cosmo)
```


```{r }
data_conc <- data_altman_exp %>% 
  mutate(conc = case_when(
            mean >= 0 & mean < 10 ~ "Group00_10",
            mean >= 10 & mean < 20 ~ "Group10_20",
            mean >= 20 & mean < 50 ~ "Group20_50",
            mean >= 50 & mean < 100 ~ "Group50_100",
            mean >= 100 & mean < 300 ~ "Group100_300",
            mean >= 300 ~ "Group300"
  )) %>% 
  pivot_longer(Hirst:Cosmo, names_to = "type", values_to = "value") %>% 
  pivot_wider(names_from = conc, values_from = value)
  

gg_conc_dens <- list()
gg_conc_hist <- list()

labels_y <- list(1, 0.065, 0.025, 0.015, 0.004, 0.0015)
labels_y <- list(0.75, 0.03, 0.015, 0.010, 0.005, 0.0012) # For 2-hours
labels_y_hist <- list(15, 13, 10, 10, 7.5, 3)
names(labels_y) <- c("Group00_10", "Group10_20", "Group20_50", "Group50_100", "Group100_300", "Group300")
names(labels_y_hist) <- c("Group00_10", "Group10_20", "Group20_50", "Group50_100", "Group100_300", "Group300")

for (j in c("Group00_10", "Group10_20", "Group20_50", "Group50_100", "Group100_300", "Group300")){
  obs <- data_conc %>% 
    filter(!is.na(!!sym(j))) %>% 
    summarise(n()/2) %>% 
    pull 
  obs <- paste("# of Observations:", obs)
  
  gg_conc_dens[[j]] <- data_conc %>% 
    filter(!is.na(!!sym(j)))  %>% 
    ggplot() +
    geom_density(aes(x = !!sym(j), col = type, fill = type), alpha = 0.15) + # The area under that whole curve should be 1. To get an estimate of the probability of certain values, you'd have to integrate over an interval on your 'y' axis, and that value should never be greater than 1.
    geom_label(label = obs, aes(x = max(!!sym(j)) * 0.7), y = labels_y[[j]]) +
    coord_cartesian(xlim = c(0, NA))
}

gg_dens_conc <- ggarrange(plotlist = gg_conc_dens, nrow = 3, ncol = 2) %>% 
  annotate_figure(top = paste("Comparison of Measurements of the Three Traps for all Species and Different Concentration Groups."),
                  bottom = text_grob("We are looking at Density Kernel Estimators for all three traps to compare the measurements between them. \n The area under each curve adds up to 1 and makes it possible to vizualise the (dis-)similarities of measurements from the three traps. It is basically a smoothed histogram.", color = swatch()[1], face = "italic", size = 10))

gg_dens_conc
```

```{r}

data_conc_plot <- data_conc %>% 
  pivot_longer(Group00_10:Group300, names_to = "group", values_to = "value") %>% 
  mutate(group = factor(group, levels = c("Group00_10", "Group10_20", "Group20_50", "Group50_100", "Group100_300", "Group300")))

means <- data_conc_plot %>% 
  group_by(group, type) %>% 
  summarise(mean = mean(value, na.rm = TRUE))

gg_boxplot_reldiff <- data_conc_plot %>% 
  ggplot(aes(x = group, y = value, fill = type)) +
  geom_boxplot(alpha = 0.6) +
  geom_point(data = means, aes(x = group, y = mean, col = type), position = position_dodge(width = 0.75), shape = 95, size = 10, show.legend = FALSE) +
  labs(x = "", y = "abs(Hirst - Cosmo) / mean(Hirst, Cosmo)", title = paste("Relative Pairwise Differences for Daily Average Pollen-Concentrations")) 

gg_boxplot_reldiff

data_conc_plot %>% 
  filter(group == "Group300",
         !is.na(value))

```

```{r eval = FALSE}
diff_selection <- list("Betula", "Fraxinus", "Poaceae", species_selection)

kable_diff <- map(diff_selection,
    ~data_conc_diff_plot %>% 
    filter(type %in% .x) %>%
    group_by(group, Traps) %>% 
    summarise(q25 = quantile(value, probs = 0.25, na.rm = TRUE),
              median = median(value, na.rm = TRUE),
              q75 = quantile(value, probs = 0.75, na.rm = TRUE)) %>% 
    ungroup %>% 
    group_by(group) %>% 
    summarise_at(vars(q25, median, q75), ~mean(.)) %>% 
    ungroup) %>% 
  bind_rows %>% 
  mutate(type = rep(c("Betula", "Fraxinus", "Poaceae", "Total"), each = 6),
         type = cell_spec(type, angle = 270, align = "center")) %>% 
  mutate_at(vars(q25, median, q75), ~scales::percent(signif(., 3), accuracy = 0.01)) %>% 
  select(type, everything()) %>% 
  setNames(c("Species", "Group", "25%-Quantile", "Median", "75%-Quantile")) %>% 
  kable(escape = FALSE, align = c("c", "c", "r", "r", "r")) %>% 
  kable_styling("striped", full_width = FALSE) %>% 
  collapse_rows(columns = 1) %>%
  pack_rows(start_row = 1, end_row = 6, indent = FALSE) %>% 
  pack_rows(start_row = 7, end_row = 12, indent = FALSE) %>% 
  pack_rows(start_row = 13, end_row = 18, indent = FALSE) %>% 
  pack_rows(start_row = 19, end_row = 24, indent = FALSE)

kable_diff
```

## Altman-Bland Plots

The well established AB-method for clinical trials can be used here as well to compare the means and differences between the two data sets. Again we see that XXX generally has higher measurements and that low concentrations lead to largest differences between the traps. The points lie within the two SD-line for the differences and hence XXX can be assumed to be strongly associated with each other. We also observe larger scattering of the points for lower concentrations.

```{r}

sd_diff <- data_altman %>% 
  summarise(sd_diff = sd(diff, na.rm = TRUE)) %>% 
  pull(sd_diff)

gg_ab1 <- data_altman %>% 
  ggplot(aes(x = mean, y = diff)) +
  geom_point(alpha = 0.5) +
  coord_cartesian(xlim = c(min(data_altman$mean), max(data_altman$mean)), ylim = c(-sd_diff[1] * 4, sd_diff[1] * 4)) +  
  geom_abline(slope = 0, intercept = 0, col = swatch()[4], alpha = 0.8) +
  geom_abline(slope = 0, intercept = sd_diff[1] * 2, col = swatch()[4], alpha = 0.8, linetype = 3) +
  geom_abline(slope = 0, intercept = sd_diff[1] * (-2), col = swatch()[4], alpha = 0.8, linetype = 3) +
  geom_smooth(alpha = 0.1) +
  labs(y = "Difference(Hirst - Cosmo)", x = "Mean(Hirst, Cosmo)") 

title <- "Altman-Bland Plot to Compare Measured and Modelled Pollen Concentrations"

ggarrange(gg_ab1) %>%
  annotate_figure(top = title, bottom = text_grob("Pairwise comparison of traps; grey line shows the Loess smother; the red line shows a theroratical perfect agreement between two traps of zero. \n The dashed red line shows the 2 * sd of the differences, where we expect the points to lie within.", color = swatch()[1], face = "italic", size = 12))

  

```

# Model Validation
## Numerical

http://www.sthda.com/english/articles/38-regression-model-validation/158-regression-model-accuracy-metrics-r-square-aic-bic-cp-and-more/

```{r}
data_conc_plot %>% 
  pivot_wider(names_from = type, values_from = value) %>% 
  summarise(
    R2 = cor(Hirst, Cosmo, use = "complete.obs")^2,
    MSE = mean((Hirst - Cosmo)^2, na.rm = TRUE),
    RMSE = sqrt(MSE),
    MAE = mean(abs(Hirst - Cosmo), na.rm = TRUE)
  )

```

## Categorical

http://www.sthda.com/english/articles/36-classification-methods-essentials/143-evaluation-of-classification-model-accuracy-essentials/

https://towardsdatascience.com/the-5-classification-evaluation-metrics-you-must-know-aa97784ff226

https://towardsdatascience.com/multi-class-metrics-made-simple-part-i-precision-and-recall-9250280bddc2
```{r}



data_valid <- data_altman_exp %>% 
  mutate(conc_hirst = case_when(
            Hirst >= 0 & Hirst < 10 ~ "Group00_10",
            Hirst >= 10 & Hirst < 20 ~ "Group10_20",
            Hirst >= 20 & Hirst < 50 ~ "Group20_50",
            Hirst >= 50 & Hirst < 100 ~ "Group50_100",
            Hirst >= 100 & Hirst < 300 ~ "Group100_300",
            Hirst >= 300 ~ "Group300"
          ),
            conc_cosmo = case_when(
            Cosmo >= 0 & Cosmo < 10 ~ "Group00_10",
            Cosmo >= 10 & Cosmo < 20 ~ "Group10_20",
            Cosmo >= 20 & Cosmo < 50 ~ "Group20_50",
            Cosmo >= 50 & Cosmo < 100 ~ "Group50_100",
            Cosmo >= 100 & Cosmo < 300 ~ "Group100_300",
            Cosmo >= 300 ~ "Group300"
            )
         ) %>% 
  filter(!is.na(conc_hirst),
         !is.na(conc_cosmo)) %>% 
  mutate_at(vars(conc_hirst, conc_cosmo), ~factor(., levels = c("Group00_10", "Group10_20", "Group20_50", "Group50_100", "Group100_300", "Group300")))
  
confusionMatrix(data_valid$conc_cosmo, data_valid$conc_hirst)
```


# Auto-Correlation

In the following we will investigate the auto-correlation of the poleno pollen measurement time series.

```{r fig.height=10, fig.width=10}

ts_autocorr_tb <- data$data_hourly %>% 
  mutate(value = if_else(is.na(value), 0, value),
         value = log(value + 1)) %>% 
  filter(taxon == "Poaceae",
         station == "Zürich",
         value > 0) %>% 
  select(datetime, value)

ts_autocorr <- as_tsibble(ts_autocorr_tb, regular = TRUE, index = datetime)

# Timeseries Plot

ts_autocorr_tb %>%
  ggplot(aes(x = datetime, y = value)) +
  geom_line() +
  ggtitle("Poaceae Pollen Concentrations for Hourly Intervals") +
  labs(x = "Date", y = paste0("Pollen Concentration [m⁻³]"))

# Index-Plot from ANOVA Residuals

# Lagged Scatterplot

ts_autocorr_tb %>% 
  mutate(lag01 = lag(value, 1),
         lag02 = lag(value, 2),
         lag04 = lag(value, 4),
         lag06 = lag(value, 6),
         lag12 = lag(value, 12),
         lag24 = lag(value, 24),
         lag48 = lag(value, 48),
         lag72 = lag(value, 72),
         lag96 = lag(value, 96)) %>% 
  pivot_longer(cols = lag01:lag96, names_to = "lag", values_to = "lagged_value") %>%
  ggplot(aes(x = value, y = lagged_value)) +
  geom_point(alpha = 0.2) +
  # coord_cartesian(xlim = c(0, 500), ylim = c(0, 500)) +
  labs(x = "", y = "") +
  facet_wrap(~ lag)


# Decomposition: As we are only looking at one year of data, decomposition into trend and seasonal effect makes little sense. This would be an interesting exercise for the future though, once we have multiple years of collected Poleno Data. Actually, there might be daily "seasonal" effects that we can filter out. Let's try :-)

dcmp <- ts_autocorr %>% 
  tsibble::fill_gaps() %>% 
  mutate(value = if_else(is.na(value), 0, value)) %>% 
  model(STL(value ~ season(window = 24)))
dcmp_components <- components(dcmp)
dcmp_components %>% autoplot()

# ACF

poleno_acf <- acf(ts_autocorr_tb$value, plot = FALSE, lag.max = 60)
poleno_acf_df <- with(poleno_acf, data.frame(lag, acf)) %>% slice(-1)
conf_level <- 0.95
ciline <- qnorm((1 - conf_level) / 2) / sqrt(nrow(ts_autocorr_tb))

ggplot(data = poleno_acf_df, mapping = aes(x = lag, y = acf)) +
  geom_hline(aes(yintercept = 0)) +
  geom_segment(mapping = aes(xend = lag, yend = 0)) +
  geom_hline(aes(yintercept = ciline), linetype = 2) + 
  geom_hline(aes(yintercept = -ciline), linetype = 2)

# poleno_acf_remainder <- acf(dcmp_components$remainder, plot = FALSE, lag.max = 60)
# poleno_acf_df_remainder <- with(poleno_acf_remainder, data.frame(lag, acf)) %>% slice(-1)
# 
# ggplot(data = poleno_acf_df_remainder, mapping = aes(x = lag, y = acf)) +
#   geom_hline(aes(yintercept = 0)) +
#   geom_segment(mapping = aes(xend = lag, yend = 0)) +
#   geom_hline(aes(yintercept = ciline), linetype = 2) + 
#   geom_hline(aes(yintercept = -ciline), linetype = 2)

# ts_autocorr %>% ACF(value) %>% autoplot()

# PACF

poleno_pacf <- pacf(ts_autocorr_tb$value, plot = FALSE, lag.max = 60)
poleno_pacf_df <- with(poleno_pacf, data.frame(lag, acf)) %>% slice(-1)

ggplot(data = poleno_pacf_df, mapping = aes(x = lag, y = acf)) +
  geom_hline(aes(yintercept = 0)) +
  geom_segment(mapping = aes(xend = lag, yend = 0)) +
  geom_hline(aes(yintercept = ciline), linetype = 2) + 
  geom_hline(aes(yintercept = -ciline), linetype = 2)

# poleno_pacf_remainder <- pacf(dcmp_components$remainder, plot = FALSE, lag.max = 60)
# poleno_pacf_df_remainder <- with(poleno_pacf_remainder, data.frame(lag, acf)) %>% slice(-1)
# 
# ggplot(data = poleno_pacf_df_remainder, mapping = aes(x = lag, y = acf)) +
#   geom_hline(aes(yintercept = 0)) +
#   geom_segment(mapping = aes(xend = lag, yend = 0)) +
#   geom_hline(aes(yintercept = ciline), linetype = 2) + 
#   geom_hline(aes(yintercept = -ciline), linetype = 2)

# ts_autocorr %>% PACF(value) %>% autoplot()

```










































