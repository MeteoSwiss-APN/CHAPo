---
title: "Implementation"
author: "Simon Adamov"
date: "August 12, 2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = FALSE,
  error = FALSE,
  warning = FALSE,
  message = FALSE,
  fig.retina = 3,
  fig.width = 10,
  fig.height = 7,
  out.width = "100%",
  out.height = "100%"
)

library(mchdwh)
if (Sys.info()["nodename"] != "tsa-ln002") library(ROracle)
library(dplyr)
library(readr)
library(tidyr)
library(purrr)
library(stringr)
library(scales)
library(psych)
library(caret)
library(e1071)
library(lubridate)
library(padr)
library(tsibble)
library(feasts)
library(fabletools)
library(kableExtra)
library(ggpubr) # old version
# These themes just look great :-)
library(ggthemr)
ggthemr("fresh")

devtools::load_all(".")

library(conflicted)
conflict_prefer(name = "select", winner = "dplyr")
conflict_prefer(name = "filter", winner = "dplyr")
conflict_prefer(name = "lag", winner = "dplyr")
conflict_prefer(name = "rescale", winner = "scales")
```

# Data Import


The data is obtained from the DWH for the current pollen season (2020). 
The Model Data from COSMO-ART is available on tsa (CSCS) in /store.

```{r }

# The following types are being measured:
# Erle - Alder - Aulne - Alnus
# Birke - Birch - Bouleau - Betula
# Gräser - Grasses - Graminées - Poaceae
# Ambrosia - Ragweed - Ambroisie - Ambrosia

species_all <- tibble(
  taxon = c(
    "Castanea",
    "Alnus",
    "Ulmus",
    "Cupressus",
    "Fraxinus",
    "Fagus",
    "Juglans",
    "Plantago",
    "Corylus",
    "Pinus",
    "Quercus",
    "Rumex",
    "Platanus",
    "Populus",
    "Poaceae",
    "Salix",
    "Betula",
    "Carpinus",
    "Urtica",
    "Taxus",
    "Picea",
    "Ambrosia"
  ),
  hirst_taxon = c(
    "kacastz0",
    "kaalnuz0",
    "kaulmuz0",
    "kacuprz0",
    "kafraxz0",
    "kafaguz0",
    "kajuglz0",
    "khplanz0",
    "kacoryz0",
    "kapinuz0",
    "kaquerz0",
    "khrumez0",
    "kaplatz0",
    "kapopuz0",
    "khpoacz0",
    "kasaliz0",
    "kabetuz0",
    "kacarpz0",
    "khurtiz0",
    "kataxuz0",
    "kapicez0",
    "khambrz0"
  ),
  cosmo_taxon = c(
    NA_character_,
    "ALNU",
    NA_character_,
    NA_character_,
    NA_character_,
    NA_character_,
    NA_character_,
    NA_character_,
    NA_character_,
    NA_character_,
    NA_character_,
    NA_character_,
    NA_character_,
    NA_character_,
    "POAC",
    NA_character_,
    "BETU",
    NA_character_,
    NA_character_,
    NA_character_,
    NA_character_,
    "AMBR"
  )
)

species <- species_all %>%
  filter(taxon %in% c("Alnus", "Ambrosia", "Betula", "Poaceae"))

stations <-
  tibble(
    hirst_station = c(
      "PDS",
      "PBU",
      "PMU",
      "PBS",
      "PZH",
      "PLZ",
      "PBE",
      # "PPY",
      "PNE",
      "PVI",
      "PLS",
      "PGE",
      "PCF",
      "PLO",
      # "BLR",
      "PLU"
    ),
    station = c(
      "Wolfgang",
      "Buchs",
      "Münsterlingen",
      "Basel",
      "Zürich",
      "Luzern",
      "Bern",
      # "Payerne",
      "Neuchâtel",
      "Visp",
      "Lausanne",
      "Genève",
      "La-Chaux-de-Fonds",
      "Locarno",
      # "Balerna",
      "Lugano"
      ),
    cosmo_station = c(
      "CHDAVO",
      "CHBUCH",
      "CHMUEN",
      "CHBASE",
      "CHZUER",
      "CHLUZE",
      "CHBERN",
      # NA_character_,
      "CHNEUC",
      "CHVISP",
      "CHLAUS",
      "CHGENE",
      "CHLACH",
      "CHLOCA",
      # NA_character_,
      "CHLUGA"
    )
  )

```

## Measurements
```{r eval = FALSE}
# Loading the Data takes a long time
# often fails when multiple years are retrieved.
data_hirst <- dwhget_surface(
  param_short = species$hirst_taxon,
  meas_cat = 204,
  year = 2017:2020,
  iso_country_cd = "CH"
) %>%
  mutate(
    datetime = ymd_hm(datetime),
    type = "Hirst",
    measurement = "concentration"
  ) %>%
  mutate_if(is.character, ~ as.factor(.)) %>%
  inner_join(species, by = c("param_short" = "hirst_taxon")) %>%
  inner_join(stations, by = c("nat_abbr" = "hirst_station")) %>%
  select(-param_short, -nat_abbr)

save(data_hirst,
  file = paste0(
    here::here(),
    "/vignettes/ext-data/data_hirst.RData"
  )
)

load(paste0(here::here(), "/vignettes/ext-data/data_hirst.RData"))

```

## Model COSMO-ART

```{r}
data_cosmo <- read_table2(paste0(
  here::here(),
  "/vignettes/ext-data/pollen.csv"
)) %>%
  # setting na during import failed for some reason
  mutate_at(vars(CHBASE:CHZUER), ~ ifelse(. < 0, NA_real_, .)) %>%
  pivot_longer(CHBASE:CHZUER, names_to = "station_tag", values_to = "value") %>%
  mutate(
    measurement = case_when(
      str_detect(PARAMETER, pattern = "sdes") ~ "phenology",
      str_detect(PARAMETER, pattern = "fe") ~ "emission",
      TRUE ~ "concentration"
    ),
    PARAMETER = str_replace_all(PARAMETER, "sdes|fe", "")
  ) %>%
  inner_join(species, by = c("PARAMETER" = "cosmo_taxon")) %>%
  inner_join(stations, by = c("station_tag" = "cosmo_station")) %>%
  mutate(
    datetime = ymd_h(paste0(
      YYYY, sprintf("%02d", MM),
      sprintf("%02d", DD),
      sprintf("%02d", hh)
    )),
    date = date(datetime),
    hour = hour(datetime),
    type = "Cosmo"
  ) %>%
  filter(between(
    datetime,
    as_datetime("2017-03-02 00:01:00"),
    as_datetime("2020-08-19 00:00:00")
  )) %>%
  select(taxon, station, date, hour, value, datetime, type, measurement)

```


# Data Bias Correction
## Measurements

The team in Payerne found that the air sucking rates of the Hirst traps are actually higher in reality than reported by the manufacturer. The traps suck in 13.5 l per minute instead of 10 l per minute. Hence our Pollen counts per 10 minutes are too high and should be reduced by a factor of 1.35.

```{r eval = FALSE}
data_hirst <- data_hirst %>%
  mutate(value_unbiased = value / 1.35)
```


# Temporal Aggregation
## Measurements

There are some general guidelines from Regula Gehrig on how to average concentration that should be followed here.

Die Stundenwerte werden wie folgt aus den 10-Minutenwerten berechnet:
z.B. Wert für 6:00 Uhr UTC wird berechnet aus 05:10 – 6:00 UTC

Die 3-h-Werte, die du auch im DWH findest, werden so berechnet:
z.B. Wert um 09:00 UTC: 06:10-09:00

Die Tageswerte werden bei den Pollen glaub ich aus den Stundenwerten berechnet aus:
01:00 – 24:00 (d.h. 00:00 – im DWH gibt es keinen Wert 24:00) UTC 


```{r eval = FALSE}

summary(data_cosmo)

data_hirst <- data_hirst %>%
  mutate(
    date = date(datetime),
    hms = format(datetime, "%H:%M:%S"),
    hour = lag(hour(datetime), 1) + 1,
    hour = ifelse(hour == 24, 0, hour)
  )
# Only look at full days
data_hirst_window <- data_hirst %>%
  filter(between(
    datetime,
    as_datetime("2017-02-08 00:10:00"),
    as_datetime("2020-09-03 00:00:00")
  ))

data_hourly <- data_hirst_window

data_2hours <- data_hirst_window %>%
  mutate(hour = case_when(
    hms > "00:00:00" & hms <= "02:00:00" ~ 2,
    hms > "02:00:00" & hms <= "04:00:00" ~ 4,
    hms > "04:00:00" & hms <= "06:00:00" ~ 6,
    hms > "06:00:00" & hms <= "08:00:00" ~ 8,
    hms > "08:00:00" & hms <= "10:00:00" ~ 10,
    hms > "10:00:00" & hms <= "12:00:00" ~ 12,
    hms > "12:00:00" & hms <= "14:00:00" ~ 14,
    hms > "14:00:00" & hms <= "16:00:00" ~ 16,
    hms > "16:00:00" & hms <= "18:00:00" ~ 18,
    hms > "18:00:00" & hms <= "20:00:00" ~ 20,
    hms > "20:00:00" & hms <= "22:00:00" ~ 22,
    hms > "22:00:00" | hms == "00:00:00" ~ 0 # For the next day already
  ))

data_3hours <- data_hirst_window %>%
  mutate(
    hour = case_when(
      hms > "00:00:00" & hms <= "03:00:00" ~ 3,
      hms > "03:00:00" & hms <= "06:00:00" ~ 6,
      hms > "06:00:00" & hms <= "09:00:00" ~ 9,
      hms > "09:00:00" & hms <= "12:00:00" ~ 12,
      hms > "12:00:00" & hms <= "15:00:00" ~ 15,
      hms > "15:00:00" & hms <= "18:00:00" ~ 18,
      hms > "18:00:00" & hms <= "21:00:00" ~ 21,
      hms > "21:00:00" | hms == "00:00:00" ~ 0 # For the next day already
    )
  )

data_6hours <- data_hirst_window %>%
  mutate(
    hour = case_when(
      hms > "00:00:00" & hms <= "06:00:00" ~ 6,
      hms > "06:00:00" & hms <= "12:00:00" ~ 12,
      hms > "12:00:00" & hms <= "18:00:00" ~ 18,
      hms > "18:00:00" | hms == "00:00:00" ~ 0 # For the next day already
    )
  )

data_12hours <- data_hirst_window %>%
  mutate(
    hour = case_when(
      hms > "00:00:00" & hms <= "12:00:00" ~ 12,
      hms > "12:00:00" | hms == "00:00:00" ~ 0 # For the next day already
    )
  )

data <- map(list(
  data_hourly,
  data_2hours,
  data_3hours,
  data_6hours,
  data_12hours
), ~ .x %>%
  # This way they will be allocated to the next day
  mutate(date = if_else(hour == 0 & hms != "00:00:00",
    date + days(1),
    date
  )) %>%
  group_by(taxon, station, date, hour, type, measurement) %>%
  summarise(value = mean(value_unbiased)) %>%
  ungroup() %>%
  mutate(datetime = ymd_hm(paste0(
    as.character(date),
    paste0(
      sprintf("%02d", hour),
      ":00"
    )
  ))) %>%
  select(taxon, station, date, hour, value, datetime, type, measurement))

data[[6]] <- data[[1]] %>%
  group_by(date, station, taxon, type, measurement) %>%
  summarise(value = mean(value)) %>%
  ungroup() %>%
  mutate(
    datetime = date,
    hour = 00:00
  ) %>%
  select(taxon, station, date, hour, value, datetime, type, measurement)

names(data) <- c(
  "data_hourly",
  "data_2hours",
  "data_3hours",
  "data_6hours",
  "data_12hours",
  "data_daily"
)

save(data, file = paste0(here::here(), "/vignettes/ext-data/data_aggs.RData"))

``` 

```{r}
load(paste0(here::here(), "/vignettes/ext-data/data_aggs.RData"))
```

## Model COSMO-Art

```{r}
data_daily_cosmo <- data_cosmo %>%
  group_by(taxon, station, date, type, measurement) %>%
  # The values are not averaged per hour but simply retrieved at every hour.
  summarise(value = mean(value, na.rm = TRUE)) %>%
  ungroup() %>%
  mutate(
    hour = 0,
    # date = date + days(1), # Depends on the definition
    datetime = ymd_hm(paste0(
      as.character(date),
      paste0(
        sprintf("%02d", hour),
        ":00"
      )
    ))
  )
```


# Missing Data and Imputation

There are no NAs in the original data. But there are some timestamps where no data was retrieved.
We will work with daily average concentrations below and hence have averaged values per hour and then per day.
Generally, missing data usually occurs when the silicone rubber bands were being exchanged.

## Padding

```{r}

data_hourly_imp <- data$data_hourly %>%
  filter(datetime >= ymd_h("2017-02-08 01")) %>%
  pad(
    start_val = ymd_h("2017-02-08 01"),
    end_val = ymd_h("2020-09-03 00"),
    group = c("station", "taxon"),
    by = "datetime",
    break_above = 2
  ) %>%
  mutate(
    date = date(datetime),
    hour = hour(datetime),
    type = "Hirst",
    measurement = "concentration",
    value = if_else(is.na(value), 0, value)
  )

data_daily_imp <- data$data_daily %>%
  filter(datetime >= ymd_h("2017-02-08 00")) %>% # Start of COSMO season?
  pad(
    start_val = ymd_h("2017-02-08 00"),
    end_val = ymd_h("2020-09-03 00"),
    group = c("station", "taxon"),
    by = "datetime",
    break_above = 2
  ) %>%
  mutate(
    date = date(datetime),
    hour = hour(datetime),
    type = "Hirst",
    measurement = "concentration",
    value = if_else(is.na(value), 0, value)
  )

data_daily_cosmo_imp <- data_daily_cosmo %>%
  pad(
    start_val = ymd_h("2017-02-08 00"),
    end_val = ymd_h("2020-09-03 00"),
    group = c("station", "taxon", "measurement"),
    by = "datetime",
    break_above = 2
  ) %>%
  mutate(
    date = date(datetime),
    hour = hour(datetime),
    type = "Cosmo",
    value = if_else(is.na(value), 0, value)
  )

data_daily_comb <- data_daily_imp %>%
  bind_rows(data_daily_cosmo_imp)

```

## Measurements

Averaging daily leads to no days with missing data points. And generally there are enough measurements per day to justify using these averages.

```{r  eval = FALSE}

# This takes ~ 2minutes - visual representation of missing data
data_hirst %>%
  as.data.frame() %>%
  missmap(y.labels = "", y.at = 1, col = swatch()[c(4, 2)])

data$data_daily %>%
  summarise_all(~ sum(is.na(.)))
summary(data$data_daily)
summary(data_daily_imp)
```

## Model COSMO-ART

There are a lot of days with missing data. Those are days outside of the blooming season (as defined in COSMO) for the respective species. I think it should be safe to set those to zero instead of NA for the upcoming code chunks (because that is actually what the model would tell you). Is there a reason that data should be missing within te pollen season as well?

```{r eval = FALSE}
data_cosmo %>%
  summarise_all(~ sum(is.na(.)))

summary(data_cosmo)
summary(data_daily_cosmo)
summary(data_daily_cosmo_imp)

data_cosmo <- data_cosmo %>%
  mutate(value = if_else(is.na(value), 0, value))
```


## Combined Daily Values



```{r }
data_daily_comb %>%
  summarise_all(~ sum(is.na(.)))

data_daily_comb %>%
  filter(!is.na(value)) %>%
  select(taxon) %>%
  unique()

summary(data_daily_comb)

```


# Time Series Plots

```{r }

plot_comb(
  data_plot = data_daily_comb,
  taxon = "Alnus",
  station = "Zürich",
  resolution = "Daily",
  combined = TRUE,
  rm_zeros = TRUE
)

```


```{r }

year_selected <- 2020

occurence <- data_daily_comb %>%
  filter(
    measurement == "concentration",
    year(datetime) == year_selected
  ) %>%
  group_by(taxon, station, type) %>%
  summarise(value = sum(value != 0)) %>%
  ungroup() %>%
  mutate(metric = "occurence")

maximum <- data_daily_comb %>%
  filter(
    measurement == "concentration",
    year(datetime) == year_selected
  ) %>%
  group_by(taxon, station, type) %>%
  summarise(value = max(value)) %>%
  ungroup() %>%
  mutate(metric = "maximum")

spi <- data_daily_comb %>%
  filter(
    measurement == "concentration",
    year(datetime) == year_selected
  ) %>%
  group_by(taxon, station, type) %>%
  summarise(value = sum(value)) %>%
  ungroup() %>%
  mutate(metric = "spi")

create_kable(occurence, title = "Occurence of Pollen [Days]")
create_kable(maximum, title = "Maximum Pollen Concentration [m⁻³]")
create_kable(spi, title = "Seasonal Pollen Integral [days*m⁻³]")

```

## Concentrations

- Cosmo modeled concentrations are generally too low in Visp and too high in Basel
- All species are modeled incorrectly at some station.
- Betula in Luzern has a weird shape in the measurements

```{r fig.height=6, fig.width=9}

# Check stations tibble for all available locations
stations_selected <- "Zürich"
# Check species tibble for all available pollen taxa
taxa_selected <- c("Alnus", "Betula", "Poaceae", "Ambrosia")
gg_timeseries <- list()

for (s in stations$station %>% sort()) {
  data_timeseries <- data_daily_comb %>%
    filter(
      taxon %in% taxa_selected,
      station %in% s,
      measurement == "concentration"
    ) %>%
    group_by(type, taxon, date, station) %>%
    summarise(value = mean(value)) %>%
    ungroup()

  large_diffs <- data_timeseries %>%
    pivot_wider(names_from = type) %>%
    mutate(
      diff = Hirst - Cosmo,
      mean_pol = (Hirst + Cosmo) / 2,
      large_diff = if_else(Hirst > 20 & ((abs(diff) + mean_pol) / mean_pol > 2),
        date, as.Date(NA)
      )
    ) %>%
    pull(large_diff) %>%
    unique()

  gg_timeseries[[s]] <- data_timeseries %>%
    ggplot(aes(x = date, y = value, col = taxon, lty = type)) +
    geom_line(alpha = 0.6) +
    geom_vline(
      xintercept = large_diffs,
      alpha = 0.1,
      col = swatch()[1],
      size = 1
    ) +
    ggtitle(paste(
      "Hourly",
      paste(taxa_selected, collapse = ", "),
      "Pollen Concentrations in", s
    )) +
    labs(
      y = expression(paste("Pollen Concentration [", m^-3, "]")),
      x = "2020 Season"
    ) +
    scale_colour_manual("Species", values = swatch()[c(2:5)]) +
    scale_linetype_discrete("Data") +
    coord_cartesian(
      xlim = c(ymd("2017-02-08"), ymd("2020-09-03")), # Define your season here
      ylim = c(0, 2000)
    )
}

gg_timeseries
```

## Phenology

- Lugano and Locarno phenologies are shifted vs measurements.
- Alnus and Betula to a lesser degree have phenology shifts.


```{r fig.height=6, fig.width=9}
# Check stations tibble for all available locations
stations_selected <- "Zürich"
# Check species tibble for all available pollen taxa
taxa_selected <- c("Alnus", "Betula", "Poaceae", "Ambrosia")
gg_pheno <- list()

for (s in stations$station %>% sort()) {
  gg_pheno[[s]] <- data_daily_comb %>%
    filter(
      taxon %in% taxa_selected,
      station %in% s,
      measurement == "concentration" & type == "Hirst" |
        measurement == "phenology" & type == "Cosmo"
    ) %>%
    group_by(type, taxon, date, station) %>%
    summarise(value = mean(value)) %>%
    ungroup() %>%
    group_by(type) %>%
    mutate(value = rescale(value, to = c(0, 100))) %>%
    ggplot(aes(x = date, y = value, col = taxon, lty = type)) +
    geom_line(alpha = 0.6) +
    ggtitle(paste(
      "Hourly",
      paste(taxa_selected, collapse = ", "),
      "Pollen Phenology in",
      s
    )) +
    labs(
      y = expression(paste("Pollen Phenology")),
      x = "2020 Season"
    ) +
    scale_colour_manual("Species", values = swatch()[c(2:5)]) +
    scale_linetype_discrete("Data") +
    coord_cartesian(
      xlim = c(ymd("2017-02-08"), ymd("2020-09-03")), # Define your season here
      ylim = c(0, 100)
    )
}

gg_pheno

```

## Emission Flux

```{r fig.height=6, fig.width=9}
# Check stations tibble for all available locations
stations_selected <- "Zürich"
# Check species tibble for all available pollen taxa
taxa_selected <- c("Alnus", "Betula", "Poaceae", "Ambrosia")
gg_emiss <- list()

for (s in stations$station %>% sort()) {
  gg_emiss[[s]] <- data_daily_comb %>%
    filter(measurement == "concentration") %>%
    bind_rows(data_cosmo) %>%
    filter(
      taxon %in% taxa_selected,
      station %in% s,
      measurement == "concentration" & type == "Hirst" |
        measurement == "emission" & type == "Cosmo"
    ) %>%
    group_by(type, taxon, date, station) %>%
    summarise(value = mean(value)) %>%
    ungroup() %>%
    group_by(type) %>%
    mutate(value = rescale(value, to = c(0, 100))) %>%
    ggplot(aes(x = date, y = value, col = taxon, lty = type)) +
    geom_line(alpha = 0.6) +
    ggtitle(paste(
      "Hourly",
      paste(taxa_selected, collapse = ", "),
      "Pollen Emission Flux in",
      s
    )) +
    labs(
      y = expression(paste("Pollen Emission Flux")),
      x = "2020 Season"
    ) +
    scale_colour_manual("Species", values = swatch()[c(2:5)]) +
    scale_linetype_discrete("Data") +
    coord_cartesian(
      xlim = c(ymd("2017-02-08"), ymd("2020-09-03")), # Define your season here
      ylim = c(0, 100)
    )
}

gg_emiss

```

# Correlation

The correlation between the measurements and modeled data can be calculated easily.
As we are only comparing two sets of data, mutliple testing is not a problem here.

Careful the correlation coefficients method have some serious shortcomings:

The correlation coefficient measures linear agreement--whether the measurements go up-and-down together. Certainly, we want the measures to go up-and-down together, but the correlation coefficient itself is deficient in at least three ways as a measure of agreement. (http://www.jerrydallal.com/LHSP/compare.htm)

- The correlation coefficient can be close to 1 (or equal to 1!) even when there is considerable bias between the two methods. For example, if one method gives measurements that are always 10 units higher than the other method, the correlation will be 1 exactly, but the measurements will always be 10 units apart.
- The magnitude of the correlation coefficient is affected by the range of subjects/units studied. The correlation coefficient can be made smaller by measuring samples that are similar to each other and larger by measuring samples that are very different from each other. The magnitude of the correlation says nothing about the magnitude of the differences between the paired measurements which, when you get right down to it, is all that really matters.
- The usual significance test involving a correlation coefficient-- whether the population value is 0--is irrelevant to the comparability problem. What is important is not merely that the correlation coefficient be different from 0. Rather, it should be close to (ideally, equal to) 1! 

## Pearson, Spearman and Kendall Correlation

A good summary of the methods and their shortcomings can be found here: https://www.statisticssolutions.com/correlation-Pearson-Kendall-spear man/

Generally the traps show a high level of correlation / association (well above 0.5). It looks like small concentrations lead to the largest discrepancies between the two sets of data.

```{r}

methods <- c("pearson", "spearman", "kendall")

data_corr <- data_daily_comb %>%
  filter(measurement == "concentration") %>%
  # For the robust methods transformation doesn't matter
  mutate(value = log10(value + 1)) %>%
  select(value, type, datetime, station, taxon) %>%
  pivot_wider(names_from = type, values_from = value)

data_corr_exp <- data_daily_comb %>%
  filter(measurement == "concentration") %>%
  select(value, type, datetime, station, taxon) %>%
  pivot_wider(names_from = type, values_from = value)

corr_matrix <- map(methods, ~ corr.test(
  data_corr %>% select(-datetime, -station, -taxon),
  # use = "complete", # There should be only complete observations
  method = .x,
  # adjust = "holm",
  alpha = .05,
  ci = TRUE,
  minlength = 5
))

```

```{r }
ggthemr("fresh")
ci <- map(corr_matrix, ~ .x %>%
  pluck(10)) %>%
  bind_rows() %>%
  round(2) %>%
  mutate(
    method = methods,
    metric = c("R-", "rho-", "tau-"),
    ci = tools::toTitleCase(paste0(
      metric,
      method,
      ": ",
      lower.adj,
      " - ",
      upper.adj
    )),
    x = rep(2, times = 3),
    y = c(4000, 2500, 1600)
  )

gg_corr <- data_corr_exp %>%
  ggplot(aes(x = Hirst, y = Cosmo)) +
  geom_point(alpha = 0.3) +
  # The smoother is dependent on the scale
  geom_smooth(alpha = 0.1) +
  geom_abline(slope = 1, intercept = 0, col = swatch()[4]) +
  geom_label(data = ci, aes(label = ci, x = x, y = y), parse = TRUE) +
  scale_x_continuous(
    name = "Measured Pollen Concentration [m⁻³]",
    limits = c(0, 1000)
  ) +
  scale_y_continuous(
    name = "Modelled Pollen Concentration [m⁻³]",
    limits = c(0, 1000)
  )

title <- tools::toTitleCase(paste0(
  "Comparison of Daily average",
  "concentrations of measured and modelled pollen concentrations"
))

gg_corr <- ggarrange(gg_corr) %>%
  annotate_figure(top = title, bottom = text_grob(paste0(
    "Pairwise correlation between measured and modelled data; grey line",
    " shows the Loess smother; the red line shows a theroratical perfect ",
    "correlation of 1. \n In the text box one can see the 95% confidence ",
    "intervals of the R-values (adjusted for multiple comparison) as obtained ",
    "by Pearson and two robust methods."
  ),
  color = swatch()[1],
  face = "italic",
  size = 10
  ))
```

```{r eval = FALSE}
ggsave(
  filename = paste0(
    here::here(),
    "/vignettes/figures/corr_plot.png"
  ),
  gg_corr, width = 12,
  height = 8
)

```

Comparison Plots

## Concentration Categories Diff-Plots

For the concentrations we are looking at some density plots and histograms to start with and then we look at the relative differences from the common mean of the three traps.

```{r}
data_altman <- data_corr %>%
  mutate(
    mean = if_else(!is.na(Hirst) | !is.na(Cosmo),
      rowSums(.[4:5], na.rm = TRUE) / 2,
      NA_real_
    ),
    diff = Hirst - Cosmo
  )

data_altman_exp <- data_corr_exp %>%
  mutate(
    mean = if_else(!is.na(Hirst) | !is.na(Cosmo),
      rowSums(.[4:5], na.rm = TRUE) / 2,
      NA_real_
    ),
    diff = Hirst - Cosmo
  )
```

This is how concentration classes are defined based on their allergenic potential.

```{r }
data_conc <- data_altman_exp %>%
  filter(mean >= 1) %>%
  mutate(conc = case_when(
    taxon == "Alnus" & mean >= 1 & mean <= 10 ~ "weak",
    taxon == "Alnus" & mean >= 11 & mean <= 69 ~ "medium",
    taxon == "Alnus" & mean >= 70 & mean <= 249 ~ "strong",
    taxon == "Alnus" & mean >= 250 ~ "verystrong",
    taxon == "Betula" & mean >= 1 & mean <= 10 ~ "weak",
    taxon == "Betula" & mean >= 11 & mean <= 69 ~ "medium",
    taxon == "Betula" & mean >= 70 & mean <= 299 ~ "strong",
    taxon == "Betula" & mean >= 300 ~ "verystrong",
    taxon == "Poaceae" & mean >= 1 & mean <= 19 ~ "weak",
    taxon == "Poaceae" & mean >= 20 & mean <= 49 ~ "medium",
    taxon == "Poaceae" & mean >= 50 & mean <= 149 ~ "strong",
    taxon == "Poaceae" & mean >= 150 ~ "verystrong",
    taxon == "Ambrosia" & mean >= 1 & mean <= 5 ~ "weak",
    taxon == "Ambrosia" & mean >= 6 & mean <= 10 ~ "medium",
    taxon == "Ambrosia" & mean >= 11 & mean <= 39 ~ "strong",
    taxon == "Ambrosia" & mean >= 40 ~ "verystrong"
  )) %>%
  pivot_longer(Hirst:Cosmo, names_to = "type", values_to = "value") %>%
  pivot_wider(names_from = conc, values_from = value)

gg_conc_dens <- list()
gg_conc_hist <- list()

labels_y <- list(1, 0.065, 0.025, 0.015, 0.004, 0.0015)
labels_y <- list(0.75, 0.03, 0.015, 0.010, 0.005, 0.0012) # For 2-hours
labels_y_hist <- list(15, 13, 10, 10, 7.5, 3)
names(labels_y) <- c("weak", "medium", "strong", "verystrong")
names(labels_y_hist) <- c("weak", "medium", "strong", "verystrong")

for (j in c("weak", "medium", "strong", "verystrong")) {
  obs <- data_conc %>%
    filter(!is.na(!!sym(j))) %>%
    summarise(n() / 2) %>%
    pull()
  obs <- paste("# of Observations:", obs)

  gg_conc_dens[[j]] <- data_conc %>%
    filter(!is.na(!!sym(j))) %>%
    ggplot() +
    # The area under that whole curve should be 1. To get an estimate of the
    # probability of certain values, you'd have to integrate over an,
    # interval on your 'y' axis and that value should never be greater than 1.
    geom_density(aes(x = !!sym(j), col = type, fill = type),
      alpha = 0.15
    ) +
    scale_color_manual(values = swatch()[c(2, 4)]) +
    geom_label(label = obs, aes(x = max(!!sym(j)) * 0.7), y = labels_y[[j]]) +
    coord_cartesian(xlim = c(0, NA))
}

gg_dens_conc <- ggarrange(plotlist = gg_conc_dens, nrow = 2, ncol = 2) %>%
  annotate_figure(
    top = paste(
      "Comparison of Measurements of the Three Traps ",
      "for all Species and Different Concentration Groups."
    ),
    bottom = text_grob(paste0(
      "We are looking at Density Kernel ",
      "Estimators for all three traps to compare the measurements between",
      " them. \n The area under each curve adds up to 1 and makes it possible",
      " to vizualise the (dis-)similarities of measurements from the",
      " three traps. It is basically a smoothed histogram."
    ),
    color = swatch()[1],
    face = "italic",
    size = 10
    )
  )


```


```{r eval = FALSE}
ggsave(
  filename = paste0(here::here(), "/vignettes/figures/density_plot.png"),
  gg_dens_conc,
  width = 12,
  height = 8
)
```
```{r}

data_conc_plot <- data_conc %>%
  pivot_longer(weak:verystrong, names_to = "group", values_to = "value") %>%
  mutate(
    group = factor(group, levels = c("weak", "medium", "strong", "verystrong")),
    reldiff = diff / mean
  ) %>%
  filter(!is.na(value))

means <- data_conc_plot %>%
  group_by(group, type) %>%
  summarise(mean = mean(reldiff))

gg_boxplot_reldiff <- data_conc_plot %>%
  ggplot(aes(x = group, y = reldiff)) +
  geom_boxplot(alpha = 0.6) +
  geom_point(
    data = means, aes(x = group, y = mean),
    position = position_dodge(width = 0.75),
    shape = 95,
    size = 10,
    show.legend = FALSE
  ) +
  labs(
    x = "",
    y = "Hirst - Cosmo / mean(Hirst, Cosmo)",
    title = paste(
      "Relative Pairwise Differences for Daily ",
      "Average Pollen-Concentrations"
    )
  ) +
  facet_wrap(~taxon)

gg_boxplot_reldiff

```

```{r eval = FALSE}
ggsave(
  filename = paste0(
    here::here(),
    "/vignettes/figures/diff_boxplot.png"
  ),
  gg_boxplot_reldiff,
  width = 12,
  height = 8
)
```

```{r eval = FALSE}
diff_selection <- list("Alnus", "Betula", "Poaceae", "Ambrosia")

kable_diff <- map(
  diff_selection,
  ~ data_conc_plot %>%
    filter(taxon %in% .x) %>%
    group_by(group, type) %>%
    summarise(
      q25 = quantile(reldiff, probs = 0.25, na.rm = TRUE),
      median = median(reldiff, na.rm = TRUE),
      q75 = quantile(reldiff, probs = 0.75, na.rm = TRUE)
    ) %>%
    ungroup() %>%
    group_by(group) %>%
    summarise_at(vars(q25, median, q75), ~ mean(.)) %>%
    ungroup()
) %>%
  bind_rows()
  
taxon <- data_conc_plot %>%
  group_by(group) %>%
  summarise(taxon = unique(taxon)) %>%
  select(taxon) %>%
  arrange(taxon) %>%
  ungroup

kable_diff %>%
  bind_cols(taxon) %>%
    mutate_at(
      vars(q25, median, q75),
      ~ scales::percent(signif(., 3),
        accuracy = 0.01
      )
    ) %>%
    select(taxon, everything()) %>%
      setNames(c(
        "Species",
        "Class",
        "25%-Quantile",
        "Median",
        "75%-Quantile"
      )) %>%
      kable(escape = FALSE, align = c("c", "c", "r", "r", "r")) %>%
      kable_styling("striped", full_width = FALSE) %>%
      collapse_rows(columns = 1) %>%
      pack_rows(start_row = 1, end_row = 3, indent = FALSE) %>%
      pack_rows(start_row = 4, end_row = 6, indent = FALSE) %>%
      pack_rows(start_row = 7, end_row = 9, indent = FALSE) %>%
      pack_rows(start_row = 10, end_row = 12, indent = FALSE)

kable_diff
```

## Altman-Bland Plots

The well established AB-method for clinical trials can be used here as well to compare the means and differences between the two data sets. Again we see that XXX generally has higher measurements and that low concentrations lead to largest differences between the traps. The points lie within the two SD-line for the differences and hence XXX can be assumed to be strongly associated with each other. We also observe larger scattering of the points for lower concentrations.

```{r}

sd_diff <- data_altman %>%
  summarise(sd_diff = sd(diff, na.rm = TRUE)) %>%
  pull(sd_diff)

gg_ab1 <- data_altman %>%
  ggplot(aes(x = mean, y = diff)) +
  geom_point(alpha = 0.5) +
  coord_cartesian(
    xlim = c(
      min(data_altman$mean),
      max(data_altman$mean)
    ),
    ylim = c(
      -sd_diff[1] * 4,
      sd_diff[1] * 4
    )
  ) +
  geom_abline(
    slope = 0,
    intercept = 0,
    col = swatch()[4],
    alpha = 0.8
  ) +
  geom_abline(
    slope = 0,
    intercept = sd_diff[1] * 2,
    col = swatch()[4],
    alpha = 0.8,
    linetype = 3
  ) +
  geom_abline(
    slope = 0,
    intercept = sd_diff[1] * (-2),
    col = swatch()[4],
    alpha = 0.8,
    linetype = 3
  ) +
  geom_smooth(alpha = 0.1) +
  labs(y = "Difference(Hirst - Cosmo)", x = "Mean(Hirst, Cosmo)") +
  facet_wrap(~taxon)

title <- paste0(
  "Altman-Bland Plot to Compare Measured ",
  "and Modelled Pollen Concentrations"
)

gg_altman <- ggarrange(gg_ab1) %>%
  annotate_figure(top = title, bottom = text_grob(paste0(
    "Pairwise comparison of traps; ",
    "grey line shows the Loess smother; the red line shows a ",
    "theroratical perfect agreement between two traps of zero. \n ",
    "The dashed red line shows the 2 * sd of the differences, where ",
    "we expect the points to lie within."
  ),
  color = swatch()[1],
  face = "italic",
  size = 12
  ))

```

```{r }
ggsave(
  filename = paste0(
    here::here(),
    "/vignettes/figures/altman-bland.png"
  ),
  gg_altman,
  width = 12,
  height = 8
)
```

# Model Validation
## Numerical

http://www.sthda.com/english/articles/38-regression-model-validation/158-regression-model-accuracy-metrics-r-square-aic-bic-cp-and-more/

```{r}
data_conc_plot %>%
  pivot_wider(names_from = type, values_from = value) %>%
  summarise(
    R2 = cor(Hirst, Cosmo, use = "complete.obs")^2,
    MSE = mean((Hirst - Cosmo)^2, na.rm = TRUE),
    RMSE = sqrt(MSE),
    MAE = mean(abs(Hirst - Cosmo), na.rm = TRUE)
  )

```

## Categorical

http://www.sthda.com/english/articles/36-classification-methods-essentials/143-evaluation-of-classification-model-accuracy-essentials/

https://towardsdatascience.com/the-5-classification-evaluation-metrics-you-must-know-aa97784ff226

https://towardsdatascience.com/multi-class-metrics-made-simple-part-i-precision-and-recall-9250280bddc2
```{r}
data_valid <- data_altman_exp %>%
  mutate(
    conc_hirst = case_when(
      taxon == "Alnus" & Hirst >= 1 & Hirst <= 10 ~ "weak",
      taxon == "Alnus" & Hirst >= 11 & Hirst <= 69 ~ "medium",
      taxon == "Alnus" & Hirst >= 70 & Hirst <= 249 ~ "strong",
      taxon == "Alnus" & Hirst >= 250 ~ "verystrong",
      taxon == "Betula" & Hirst >= 1 & Hirst <= 10 ~ "weak",
      taxon == "Betula" & Hirst >= 11 & Hirst <= 69 ~ "medium",
      taxon == "Betula" & Hirst >= 70 & Hirst <= 299 ~ "strong",
      taxon == "Betula" & Hirst >= 300 ~ "verystrong",
      taxon == "Poaceae" & Hirst >= 1 & Hirst <= 19 ~ "weak",
      taxon == "Poaceae" & Hirst >= 20 & Hirst <= 49 ~ "medium",
      taxon == "Poaceae" & Hirst >= 50 & Hirst <= 149 ~ "strong",
      taxon == "Poaceae" & Hirst >= 150 ~ "verystrong",
      taxon == "Ambrosia" & Hirst >= 1 & Hirst <= 5 ~ "weak",
      taxon == "Ambrosia" & Hirst >= 6 & Hirst <= 10 ~ "medium",
      taxon == "Ambrosia" & Hirst >= 11 & Hirst <= 39 ~ "strong",
      taxon == "Ambrosia" & Hirst >= 40 ~ "verystrong"
    ),
    conc_cosmo = case_when(
      taxon == "Alnus" & Cosmo >= 1 & Cosmo <= 10 ~ "weak",
      taxon == "Alnus" & Cosmo >= 11 & Cosmo <= 69 ~ "medium",
      taxon == "Alnus" & Cosmo >= 70 & Cosmo <= 249 ~ "strong",
      taxon == "Alnus" & Cosmo >= 250 ~ "verystrong",
      taxon == "Betula" & Cosmo >= 1 & Cosmo <= 10 ~ "weak",
      taxon == "Betula" & Cosmo >= 11 & Cosmo <= 69 ~ "medium",
      taxon == "Betula" & Cosmo >= 70 & Cosmo <= 299 ~ "strong",
      taxon == "Betula" & Cosmo >= 300 ~ "verystrong",
      taxon == "Poaceae" & Cosmo >= 1 & Cosmo <= 19 ~ "weak",
      taxon == "Poaceae" & Cosmo >= 20 & Cosmo <= 49 ~ "medium",
      taxon == "Poaceae" & Cosmo >= 50 & Cosmo <= 149 ~ "strong",
      taxon == "Poaceae" & Cosmo >= 150 ~ "verystrong",
      taxon == "Ambrosia" & Cosmo >= 1 & Cosmo <= 5 ~ "weak",
      taxon == "Ambrosia" & Cosmo >= 6 & Cosmo <= 10 ~ "medium",
      taxon == "Ambrosia" & Cosmo >= 11 & Cosmo <= 39 ~ "strong",
      taxon == "Ambrosia" & Cosmo >= 40 ~ "verystrong"
    )
  ) %>%
  filter(
    !is.na(conc_hirst),
    !is.na(conc_cosmo)
  ) %>%
  mutate_at(vars(conc_hirst, conc_cosmo),
  ~ factor(., levels = c("weak", "medium", "strong", "verystrong")))

confusionMatrix(data_valid$conc_cosmo, data_valid$conc_hirst)
```

# Temporal Dependencies

## Scatterplots

```{r}

ts_autocorr_tb <- data_hourly_imp %>%
  mutate(
    value = if_else(is.na(value), 0, value),
    value = log(value + 1)
  ) %>%
  filter(
    taxon == "Poaceae",
    station == "Zürich",
    year(datetime) == 2019,
    value > 0
  ) %>%
  select(datetime, value)

ts_autocorr <- as_tsibble(ts_autocorr_tb, regular = TRUE, index = datetime)

# Lagged Scatterplot

ts_autocorr_tb %>%
  mutate(
    lag01 = lag(value, 1),
    lag02 = lag(value, 2),
    lag04 = lag(value, 4),
    lag06 = lag(value, 6),
    lag12 = lag(value, 12),
    lag24 = lag(value, 24),
    lag48 = lag(value, 48),
    lag72 = lag(value, 72),
    lag96 = lag(value, 96)
  ) %>%
  pivot_longer(
    cols = lag01:lag96,
    names_to = "lag",
    values_to = "lagged_value"
  ) %>%
  ggplot(aes(x = value, y = lagged_value)) +
  geom_point(alpha = 0.2) +
  # coord_cartesian(xlim = c(0, 500), ylim = c(0, 500)) +
  labs(x = "", y = "") +
  facet_wrap(~lag)
```


## Decomposition and Auto-Correlation

In the following we will investigate the auto-correlation of the poleno pollen measurement time series.

```{r fig.height=10, fig.width=10}

# Decomposition: As we are only looking at one year of data,
# decomposition into trend and seasonal effect makes little sense.
# This would be an interesting exercise for the future though,
# once we have multiple years of collected Poleno Data.
# Actually, there might be daily "seasonal" effects that we can filter out.
# Let's try :-)

dcmp <- ts_autocorr %>%
  tsibble::fill_gaps() %>%
  mutate(value = if_else(is.na(value), 0, value)) %>%
  model(STL(value ~ season(window = 24)))
dcmp_components <- components(dcmp)
dcmp_components %>% autoplot()

# ACF

poleno_acf <- acf(ts_autocorr_tb$value, plot = FALSE, lag.max = 60)
poleno_acf_df <- with(poleno_acf, data.frame(lag, acf)) %>% slice(-1)
conf_level <- 0.95
ciline <- qnorm((1 - conf_level) / 2) / sqrt(nrow(ts_autocorr_tb))

ggplot(data = poleno_acf_df, mapping = aes(x = lag, y = acf)) +
  geom_hline(aes(yintercept = 0)) +
  geom_segment(mapping = aes(xend = lag, yend = 0)) +
  geom_hline(aes(yintercept = ciline), linetype = 2) +
  geom_hline(aes(yintercept = -ciline), linetype = 2)

ts_autocorr %>%
  tsibble::fill_gaps() %>%
  ACF(value) %>%
  autoplot()



```

```{r eval = FALSE}

# PACF

poleno_pacf <- pacf(ts_autocorr_tb$value, plot = FALSE, lag.max = 60)
poleno_pacf_df <- with(poleno_pacf, data.frame(lag, acf)) %>% slice(-1)

ggplot(data = poleno_pacf_df, mapping = aes(x = lag, y = acf)) +
  geom_hline(aes(yintercept = 0)) +
  geom_segment(mapping = aes(xend = lag, yend = 0)) +
  geom_hline(aes(yintercept = ciline), linetype = 2) +
  geom_hline(aes(yintercept = -ciline), linetype = 2)

poleno_acf_remainder <- acf(dcmp_components$remainder,
  plot = FALSE,
  lag.max = 60
)
poleno_acf_df_remainder <- with(
  poleno_acf_remainder,
  data.frame(lag, acf)
) %>%
  slice(-1)

ggplot(data = poleno_acf_df_remainder, mapping = aes(x = lag, y = acf)) +
  geom_hline(aes(yintercept = 0)) +
  geom_segment(mapping = aes(xend = lag, yend = 0)) +
  geom_hline(aes(yintercept = ciline), linetype = 2) +
  geom_hline(aes(yintercept = -ciline), linetype = 2)

poleno_pacf_remainder <- pacf(dcmp_components$remainder,
  plot = FALSE,
  lag.max = 60
)
poleno_pacf_df_remainder <- with(
  poleno_pacf_remainder,
  data.frame(lag, acf)
) %>%
  slice(-1)

ggplot(data = poleno_pacf_df_remainder, mapping = aes(x = lag, y = acf)) +
  geom_hline(aes(yintercept = 0)) +
  geom_segment(mapping = aes(xend = lag, yend = 0)) +
  geom_hline(aes(yintercept = ciline), linetype = 2) +
  geom_hline(aes(yintercept = -ciline), linetype = 2)

ts_autocorr %>%
  tsibble::fill_gaps() %>%
  PACF(value) %>%
  autoplot()
```








































