---
title: "AutoPollen - Implementierung der Daten in die Prognosemodelle"
author: "Simon Adamov"
date: "7/13/2020"
output: html_document
---

```{r echo = FALSE}
knitr::opts_chunk$set(echo = FALSE,
                      error = FALSE, 
                      warning = FALSE, 
                      message = FALSE,
                      fig.retina =3,
                      fig.width = 10,
                      fig.height = 7,
                      fig.align = "center",
                      out.width = "100%",
                      out.height = "100%")
```

# Einleitung

Im Projekt CHAPo werden automatische Pollenmessgeräte auf dem ganzem Gebiet der Schweiz installiert. Diese neuartigen Fallen werden von der Firma Swisens produziert und tragen den Namen Poleno. Der grosse Vorteil für die Prognose-Modelle liegt in der Verfügbarkeit der Daten; diese werden ab 2021 in Echtzeit an das Rechenzentrum der Meteoschweiz gesendet. Zudem konnten die Poleno Fallen in einem ersten Vergleich auch zeigen, dass sie bereits bei geringeren Pollen-Konzentrationen robuste Messungen ermöglichen. In bisherigen Analysen wurden die Roadmap und die Messorte für die neuen Fallen definiert. Dieses Dokument soll aufweisen inwiefern die Prognose-Modelle am meisten von den neuen Daten profitieren können. Dazu werden Module und Code-Stellen der Cosmo Code-Datenbank ausgewählt, die am ehesten von den zeitlich höher aufgelösten Daten profitieren könnten.

Generell werden folgende Fragestellungen geklärt werden müssen:

- Welche Parameter / Funktionen sollen von der neuen Daten Assimilation profitieren?
- Wie häufig soll der jeweilge Parameter / Funktion an die momentanen Messwerte angepasst werden?
- Kann dieselbe Methode für alle relevanten Pollentaxa verwendet werden?
- Wie soll räumlich zwischen den rund 20 Stationen interpoliert werden.
- Wie kann die Güte der neuen Methoden überprüft werden (was dient als "Ground-Truth")?
- Wird die maximale Pollenemission pro Tag durch die neuen Daten aufgeweicht?

# Module und Code-Fragmente

Die Pollen sind anhand des folgendes Schemas in COSMO-ART implementiert.

```{r}
knitr::include_graphics("figures/diagram_implementation.png")
```

Die Bedeutung der Symbole und das Diagramm stammen von Zink, 2014.

```{r out.width="75%"}
knitr::include_graphics("figures/parameters.png")
```

Folgende Teilgebiete der Pollen-Implementierung könnten von den neuen Echtzeit-Daten profitieren und sind verantwortlich für den grössten Teil der Unsicherheiten in der numerischen Pollenvorhersage:

- Phänologie: Beginn/Ende der Pollensaison von den real-time Pollendaten triggern (oder verhindern) lassen (z.B. via neu variables Feld der kritischen T-summe)
- Stärke der Pollensaison: interannuelle Variabilität der kritischen Temperatursumme durch Mast- und Samenjahren (indirekte Skalierung der Verbreitungskarte )

Die modellierte Pollenkonzentration in der Luft kann dabei nicht einfach näher an die Messwerte gezogen werden (Nudging der Messwerte), da diese Information schnell im Modell verloren geht, vielmehr müssen andere Parameter angepasst werden (Nudging der Parameter).

Die folgenden beiden Parameter kommen als Kandidaten für Echtzeit Anpassungen in Frage:

- Fraction of the grid box covered with the specific plant \\(f_{Q,cov}\\)
- Mathematical description of the course of the pollen season \\(f_{Q,seas}\\)

Der erste der beiden Parameter wird dem Modell als Grid-Inputfeld bereit gestellt (Verbreitungskarte). Es kommen sowohl direkte Skalierung dieses Feldes in Frage als auch indirekte Skalierung nachdem das Feld bereit gestellt wurden. Momentan scheint letzere Option die einfachere zu sein, da die indirekte Skalierung bei jedem Modelllauf und Zeitschritt durchgeführt werden kann. Der zweite Parameter, die Saisonalität der Pollenphänologie, wird im Modul pol_seasons jeweils berechnet und kann direkt optimiert werden.

Das übergeschaltete Modul im Pollen-Code heisst "organize_pollen", das eine grosse Anzahl Subroutinen des Pollen-Codes aufruft.

```{r}
knitr::include_graphics("figures/organize_pollen_cgraph.png")
```

Die beiden oben genannten Parameter werden also über den folgenden Weg aufgerufen:

- lmorg -> organize_pollen -> pol_emissions::emiss_p -> emiss_formula_helbig
- lmorg -> organize_pollen -> pol_emissions::emiss_p -> emiss_formula_zink
- lmorg -> organize_pollen -> pol_seasons::calc_saisl

Die erste wird nicht mehr benutzt, da Zink bessere Resultate liefert.

## Die Daten

Die Echtzeit-Daten der Poleno-Geräte können im Modul data_pollen geladen werden. MDS ist verantwortlich für eine technisch robuste Bereitstellung der Messungen. Momentan werden die Pollen-Messungen nicht direkt im Code verwendet. Eine Pipeline dafür muss also zuerst errichtet und die Schnittstellen definiert werden.

## Die Verbreitungskarte

Wie oben erwähnt wird nicht die Karte direkt skaliert sondern viel eher könnte psi_emiss für jede grid box durch eine neue datenbasierte Funktion genudged werden.

```{fortran eval = FALSE, echo = TRUE}
MODULE pol_emissions
  SUBROUTINE emiss_formula_zink(isp,polname)
    !---------------------------------------------------------------------!
    ! Emission from the reservoir into the atmosphere                     !
    !---------------------------------------------------------------------!
    !...........................................................
    ! Calculation of the emission flux:
    !...........

    c_max = Res_old(i,j,isp) / deltaz(i,j)  !use res_old instead of Res_old?
    cquell = c_max * f_e_rh * f_e_tke * psi_wet

    cpollen_npollen(i,j,ke,isp) = cpollen_npollen(i,j,ke,isp) * rho(i,j,ke)
    cpollen_npollen(i,j,ke,isp) = cpollen_npollen(i,j,ke,isp) + cquell
    cpollen_npollen(i,j,ke,isp) = cpollen_npollen(i,j,ke,isp) / rho(i,j,ke)
    psi_emis = cquell * deltaz(i,j)
    fe_plant(i,j,isp) = cquell * deltaz(i,j) / dtpollen
    res_old(i,j,isp) = res_old(i,j,isp) - psi_emis

    ! Summing up the amount of released pollen for the current day:

    ! Double precision is needed for julian days
    zjday_new_local = zjday_new + REAL(rlon(i,j), KIND=idoubles) / &
                      (2._idoubles * 3.1415927_idoubles)
    zjday_now_local = zjday_now + REAL(rlon(i,j), KIND=idoubles) / &
                      (2._idoubles * 3.1415927_idoubles)

    IF (floor(zjday_new_local) .gt. floor(zjday_now_local)) THEN
      Res_new_sum(i,j,isp) = 0._wp
    ELSE
      Res_new_sum(i,j,isp) = Res_new_sum(i,j,isp) + Res_new(i,j,isp)
    ENDIF
    
```


## Die Saisonalität

The mathematical description of the pollen season \\(f_{Q,seas}\\) is taken from the phenological model developed for the operational numerical pollen forecasts at MeteoSwiss (compare Section 2.3.1). It is used as an input parameter for the emission parameterization in both model congurations. See section 3.3.3 in Zink's Dissertation for more information. [Zink, 2014]

Im Modul pol_seasons wird \\(f_{Q,seas}\\) bereit gestellt. In der letzten Subroutine des Modules, genannt calc_sdes könnten die zuvor geladenen Echtzeit-Daten implementiert werden. An dieser Stelle wird bereits jetzt ein Taxa-spezifischer Tuning-Faktor angewendet den man optmieren könnte.

```{fortran eval = FALSE, echo = TRUE}
MODULE pol_seasons

!This module calculates the phenological state of the plants (Variable f_q_seas) that
!is used in the pollen emission calculation (module pol_emissions). f_q_seas is zero
!before and after the pollen season. During the pollen season it ranges from
!zero and  (almost) one. The higher f_q_seas the more plants are flowering.
!
!The current implementation includes birch, alder and grasses. For birch and alder, a temperature
!sum model for the start and the end of the pollen season is provided. This model is optimized
!for Swiss pollen data. For grasses, the implemented approach includes a temperature sum model
!for the start of the pollen season. The end of the pollen season is calculated via the
!climatological length of the grass pollen season. Most of the subroutines can
!handle further species some have to be adapted though. For one further species
!(Ambrosia or any other) the structures are already implemented.

USE data_pollen,        ONLY: isp, isp_pollen, var_pollen, jul_days_excl, t_base, &
                              ctsum, t2m_act_field_path, t2m_clim_stns_path,      &
                              tthrs, tthre, f_q_seas, saisn, saisa,               &
                              saisl, dtpollen

SUBROUTINE calc_saisl(ierrstat)

  ! The calculations of this subroutine use station data that are located on the whole domain.
  
  CALL READ_ATAB(file,nrow,lablen,icol,fcol,ncol,rlabel,           &
               iarray,farray,array,rclabel,ilabel,flabel,alabel, &
               header_info,iostat,iomsg)

  ! calculate the length of the season at the 31 stations using a) saisn, b) ctsum,
  ! c) clim. station t2m data gather fields to select t2m values at stations
  CALL gather_field (ctsum    (:,:,isp), ie,je, ctsum_tot, ie_tot,je_tot, -1, ierrstat)
  CALL gather_field (saisa    (:,:,isp), ie,je, saisa_tot, ie_tot,je_tot, -1, ierrstat)
  CALL gather_field (tthrs_red(:,:,isp), ie,je, thr_s_tot, ie_tot,je_tot, -1, ierrstat)
  CALL gather_field (tthre    (:,:,isp), ie,je, thr_e_tot, ie_tot,je_tot, -1, ierrstat)

END SUBROUTINE calc_saisl

SUBROUTINE calc_sdes()

  ! Calculation of f_q_seas using saisl und saisn (for all gridpoints incl halo)
  f_q_seas(:,:,isp) = 0._wp ! set f_q_seas to zero before updating
  DO j=1, je
    DO i=1, ie
      IF (saisn(i,j,isp) > 1._wp) THEN
        ! derived from formula for f_q_seas for birch (set to zero and solve
        ! for tune_flower); used to compress final function to match saisl
        ! ensure that there is no division by zero
        IF (saisl(i,j,isp) > 0._wp) THEN
          tune_flower = (LOG(499._wp) + 8._wp) / saisl(i,j,isp)
        END IF
        f_q_seas(i,j,isp) = 1.03_wp *                               &
            ! controls rise of the sigmoid function
                           (1._wp / (1._wp + EXP(-0.3_wp   *        &
                           saisn(i,j,isp) + 3.5_wp)) - 0.03_wp) *   &
            ! controls the decline of the sigmoid function
                           (1._wp / (1._wp + EXP(tune_flower  *     &
                           saisn(i,j,isp) - 7._wp)) - 0.001_wp)
      END IF
    END DO
  END DO

END SUBROUTINE calc_sdes
```

# Interpolation

Wir kreieren wohl ein neues Grip-Input Feld mit den interpolierten Messwerten, anhand welchem die modellierten Pollen-Konzentrationen optimiert werden können (via Emissions Parameter).

- Die Clusteranalyse von APK könnte hier helfen.
- ML vs. Standard Methoden: Spatial Statistics mit räumlichen und zeitlichen Autokorrelationen (Andreas Papritz)
- Kriging um die bodennahen Messwerte vorherzusagen und die Ähnlichkeit zu den umliegenden Messstationen zu berechnen.
- https://opengeohub.org/machine-learning-spatial-data für ML Approaches
- Topographie in Alpen wird potentiell problematisch
- Wie stark verzögert, wie häufig und in welchem Radius sollen die Emissions-Parameter angepasst werden?

# Validation

- Die statistische Vergleichsstudie von Hirst und Poleno Fallen von APK sollte hier hilfreich sein?
- Welche Validations-Metriken sollen verwendet werden (evtl auch kategorische)?
- Soll man Hirst oder Poleno als Ground-Truth anerkennen? 
- Zu welchen Zeitpunkten im Jahr soll verifiziert werden?
- Werden eventuell noch zusätzliche Spezies analysiert?





































